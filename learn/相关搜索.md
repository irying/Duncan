## 相关搜索

### 需求

**1.站在用户角度，会搜近义词跟后继词，后继词是跟搜索词有交集的词**

​	近义词： 苹果电脑、apple电脑、Mac..

​	后继词：金山、金山 雷军、金山 WPS..

**2.站在搜索结果角度，如果某个搜索结果出现在了不同的搜索词的结果集中，那么这些个搜索词很可能是相关的，<u>如果这个搜索结果在不同的搜索词下都被点击了</u>，那么这些个词的相关性就更高了。** 



### 算法

#### 1.纯后继词：以用户和搜索词推搜索词

​	1）搜索日志那次这样的记录

```
key:搜索词 time:搜索时间 用户A result:a,b,c,d,e（前5个搜索结果）
key:搜索词 time:搜索时间 用户B result:b,h,i,d,e（前5个搜索结果）
key:搜索词 time:搜索时间 用户C result:b,h,a,c,b（前5个搜索结果）
...
```

​	规则：某个词b只有出现在5个用户的相同的搜索词a的后继词中才算一个A的后继词

```
key：a succeed：b,c,d.....
```



#### 2.协同过滤：以搜索词推相似的搜索词，相似性取决于搜索结果或者点击结果

```
key:搜索词A result:a,b,c,d,e（前5个搜索结果）
key:搜索词B result:a,f,c,g,m（前5个搜索结果）
```

每一行数据的result想象成一篇文档，result里面的每个结果集想象成一个词语，那么这其实就是求两个文档之间的相似性了，**从头到尾过一遍就可以找到每一行数据和它最相似的数据了**，而每一行可以用当行的搜索词表示，这么一算下来数据就变成这样子了，后面的括号里面是两个词的相似度。

```
key：搜索词A   succeed：搜索词B(0.8)  搜索词C(0.6).....
key：搜索词B   succeed：搜索词A(0.8)  搜索词E(0.7).....
```

**上面的协同过滤算法的数据是词和后继词，这里是词和点击结果** 

##### 加强版1

如果某个搜索结果出现在了不同的搜索词的结果集中，那么这些个搜索词很可能是相关的，如果这个<u>搜索结果在不同的搜索词下都被点击了，那么这些个词的相关性就更高了。</u> 

```
key：搜索词A click:结果A 结果B 结果C
```

##### 加强版2

```
结果A  ： 搜索词A  搜索词B 搜索词C....
结果B  ： 搜索词B  搜索词A 搜索词D.....
```

做个倒排，我们把一行看成一篇文档，每个搜索词看成一个词，不就是求各个词的相似性嘛，祭出神器`Word2Vec`，直接计算每个搜索词的`词向量`，然后计算各个词向量之间的相似性，就可以算出每个词应该推荐的词了。 



## 分层

数据层：
	采集搜索结果数据（搜索词，uid，5分钟内的搜索词）

​	采集搜索结果点击数据（搜索词，uid，点击的模板id,标题等信息）

算法层：



#### 每次点击搜索上报的数据

uuid维度协同过滤 or 后继词寻找

uuidA->[keyword..]
uuidB->[keyword...]

| uuid | userid | keyword | create_time |
| ---- | ------ | ------- | ----------- |
|      |        |         |             |

#### 每次在搜索结果页,点击模板上报的数据

keyword维度协同过滤

keywordA->[mid..]
keywordB->[mid...]

| keyword | mid        | create_time |
| ------- | ---------- | ----------- |
| 搜索词  | 点击的模板 | 创建时间    |

